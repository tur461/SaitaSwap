{"ast":null,"code":"import { ContractServices } from \"../../services/ContractServices\";\nimport default_icon from \"../../assets/images/token_icons/default.svg\";\nimport { UserService } from \"../../services/UserService\";\nimport { checkUserLpTokens, saveUserLpTokens } from \"./PersistActions\";\nimport { WETH } from \"../../assets/tokens\";\nimport { ExchangeService } from \"../../services/ExchangeService\";\nexport const searchTokenByNameOrAddress = address => async (dispatch, getState) => {\n  try {\n    const {\n      persist: {\n        tokenList\n      }\n    } = getState();\n\n    if (address.length === 42) {\n      const filteredTokenList = tokenList.filter(token => token.address.toLowerCase().includes(address.toLowerCase()));\n\n      if (filteredTokenList.length > 0) {\n        return filteredTokenList;\n      }\n\n      const tokenDecimal = await ContractServices.getDecimals(address);\n      const tokenName = await ContractServices.getTokenName(address);\n      const tokenSymbol = await ContractServices.getTokenSymbol(address);\n      const tokenBalance = await ContractServices.getTokenBalance(address);\n      const obj = {\n        icon: default_icon,\n        name: tokenName,\n        address,\n        isAdd: true,\n        isDel: false,\n        decimals: tokenDecimal,\n        symbol: tokenSymbol\n      };\n      tokenList.push(obj);\n      return tokenList;\n    }\n\n    return tokenList.filter(token => token.name.toLowerCase().includes(address.toLowerCase()));\n  } catch (error) {\n    console.log(\"Error: \", error);\n    return error;\n  }\n};\nexport const delTokenFromList = data => async (dispatch, getState) => {\n  try {\n    const {\n      persist: {\n        tokenList\n      }\n    } = getState();\n    tokenList.splice(tokenList.findIndex(a => a.address.toLowerCase() === data.address.toLowerCase()), 1);\n    return tokenList;\n  } catch (error) {\n    console.log(\"Error: \", error);\n    return error;\n  }\n};\nexport const getUserLPTokens = () => async (dispatch, getState) => {\n  try {\n    const {\n      persist: {\n        updateUserLpTokens\n      }\n    } = getState();\n\n    if (!updateUserLpTokens) {\n      dispatch(saveUserLpTokens([]));\n      let lpTokensCount = await UserService.getPairsCount();\n      lpTokensCount = lpTokensCount.data.count;\n      const limit = 100;\n      const totalPages = Math.ceil(lpTokensCount / limit); // let lpTokensArr = [];\n\n      for (let page = 1; page <= totalPages; page++) {\n        let lpTokens = await UserService.getPairs({\n          page,\n          limit\n        });\n        lpTokens = lpTokens.data; // lpTokensArr = lpTokensArr.concat(lpTokens);\n\n        for (let lp of lpTokens) {\n          await dispatch(commonLpToken(lp));\n        } // console.log(\"LPTOKENS:\", lpTokens);\n\n      }\n    }\n  } catch (error) {\n    console.log(\"Error: \", error);\n    return error;\n  }\n};\nexport const commonLpToken = lp => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        persist: {\n          isUserConnected,\n          tokenList,\n          userLpTokens\n        }\n      } = getState();\n      const balance = await ContractServices.getTokenBalanceFull(lp.pair, isUserConnected);\n\n      if (balance > 0) {\n        let userLpTokensArr = userLpTokens;\n        let token0Obj = {},\n            token1Obj = {},\n            token0Deposit = 0,\n            token1Deposit = 0,\n            poolShare = \"0\",\n            ratio = 0;\n        const totalSupply = await ContractServices.getTotalSupply(lp.pair);\n        ratio = balance / totalSupply;\n        poolShare = (balance / totalSupply * 100).toFixed(2);\n        const reserves = await ExchangeService.getReserves(lp.pair);\n\n        if (lp.token0.toLowerCase() === WETH.toLowerCase()) {\n          token0Obj = tokenList.find(d => d.address === \"BNB\");\n        } else {\n          token0Obj = tokenList.find(d => d.address.toLowerCase() === lp.token0.toLowerCase());\n        }\n\n        if (lp.token1.toLowerCase() === WETH.toLowerCase()) {\n          token1Obj = tokenList.find(d => d.address === \"BNB\");\n        } else {\n          token1Obj = tokenList.find(d => d.address.toLowerCase() === lp.token1.toLowerCase());\n        } //lp deposit\n\n\n        token0Deposit = ratio * (reserves[\"_reserve0\"] / 10 ** token0Obj.decimals);\n        token1Deposit = ratio * (reserves[\"_reserve1\"] / 10 ** token1Obj.decimals);\n        const data = { ...lp,\n          token0Obj,\n          token1Obj,\n          token0Deposit,\n          token1Deposit,\n          balance,\n          poolShare\n        };\n        userLpTokensArr = [...userLpTokensArr, data];\n        dispatch(saveUserLpTokens(userLpTokensArr));\n      }\n    } catch (error) {}\n  };\n};\nexport const addLpToken = lp => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        persist: {\n          isUserConnected,\n          tokenList,\n          userLpTokens\n        }\n      } = getState();\n\n      if (lp) {\n        dispatch(checkUserLpTokens(true));\n        let userLpTokensArr = userLpTokens;\n        const balance = await ContractServices.getTokenBalanceFull(lp.pair, isUserConnected);\n\n        if (balance > 0) {\n          let token0Obj = {},\n              token1Obj = {},\n              token0Deposit = 0,\n              token1Deposit = 0,\n              poolShare = \"0\",\n              ratio = 0;\n          const totalSupply = await ContractServices.getTotalSupply(lp.pair);\n          ratio = balance / totalSupply;\n          poolShare = (balance / totalSupply * 100).toFixed(2);\n          const reserves = await ExchangeService.getReserves(lp.pair);\n\n          if (lp.token0.toLowerCase() === WETH.toLowerCase()) {\n            lp.token0 = 'BNB';\n            token0Obj = tokenList.find(d => d.address === \"BNB\");\n          } else {\n            token0Obj = tokenList.find(d => d.address.toLowerCase() === lp.token0.toLowerCase());\n          }\n\n          if (lp.token1.toLowerCase() === WETH.toLowerCase()) {\n            lp.token1 = 'BNB';\n            token1Obj = tokenList.find(d => d.address === \"BNB\");\n          } else {\n            token1Obj = tokenList.find(d => d.address.toLowerCase() === lp.token1.toLowerCase());\n          } //lp deposit\n\n\n          token0Deposit = ratio * (reserves[\"_reserve0\"] / 10 ** token0Obj.decimals);\n          token1Deposit = ratio * (reserves[\"_reserve1\"] / 10 ** token1Obj.decimals);\n          const data = { ...lp,\n            token0Obj,\n            token1Obj,\n            token0Deposit,\n            token1Deposit,\n            balance,\n            poolShare\n          };\n          let check = true;\n\n          for (let oldLp of userLpTokens) {\n            if (oldLp.pair.toLowerCase() === lp.pair.toLowerCase()) {\n              check = false;\n            }\n          }\n\n          if (check) {\n            userLpTokensArr = [...userLpTokensArr, data];\n            await dispatch(saveUserLpTokens(userLpTokensArr));\n          }\n\n          return data;\n        } else {\n          return null;\n        }\n      }\n    } catch (error) {\n      console.log(\"Error: \", error);\n      return error;\n    }\n  };\n};","map":{"version":3,"sources":["/home/user/Desktop/nm/SaitaSwap/src/redux/actions/ExchangeActions.js"],"names":["ContractServices","UserService","checkUserLpTokens","saveUserLpTokens","WETH","ExchangeService","searchTokenByNameOrAddress","address","dispatch","getState","persist","tokenList","length","filteredTokenList","filter","token","toLowerCase","includes","tokenDecimal","getDecimals","tokenName","getTokenName","tokenSymbol","getTokenSymbol","tokenBalance","getTokenBalance","obj","icon","default_icon","name","isAdd","isDel","decimals","symbol","push","error","console","log","delTokenFromList","data","splice","findIndex","a","getUserLPTokens","updateUserLpTokens","lpTokensCount","getPairsCount","count","limit","totalPages","Math","ceil","page","lpTokens","getPairs","lp","commonLpToken","isUserConnected","userLpTokens","balance","getTokenBalanceFull","pair","userLpTokensArr","token0Obj","token1Obj","token0Deposit","token1Deposit","poolShare","ratio","totalSupply","getTotalSupply","toFixed","reserves","getReserves","token0","find","d","token1","addLpToken","check","oldLp"],"mappings":"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","sourcesContent":["import { ContractServices } from \"../../services/ContractServices\";\nimport default_icon from \"../../assets/images/token_icons/default.svg\";\nimport { UserService } from \"../../services/UserService\";\nimport { checkUserLpTokens, saveUserLpTokens } from \"./PersistActions\";\nimport { WETH } from \"../../assets/tokens\";\nimport { ExchangeService } from \"../../services/ExchangeService\";\n\nexport const searchTokenByNameOrAddress =\n  (address) => async (dispatch, getState) => {\n    try {\n      const {\n        persist: { tokenList },\n      } = getState();\n\n      if (address.length === 42) {\n        const filteredTokenList = tokenList.filter((token) =>\n          token.address.toLowerCase().includes(address.toLowerCase())\n        );\n        if (filteredTokenList.length > 0) {\n          return filteredTokenList;\n        }\n        const tokenDecimal = await ContractServices.getDecimals(address);\n        const tokenName = await ContractServices.getTokenName(address);\n        const tokenSymbol = await ContractServices.getTokenSymbol(address);\n        const tokenBalance = await ContractServices.getTokenBalance(address);\n        const obj = {\n          icon: default_icon,\n          name: tokenName,\n          address,\n          isAdd: true,\n          isDel: false,\n          decimals: tokenDecimal,\n          symbol: tokenSymbol,\n        };\n        tokenList.push(obj);\n        return tokenList;\n      }\n      return tokenList.filter((token) =>\n        token.name.toLowerCase().includes(address.toLowerCase())\n      );\n    } catch (error) {\n      console.log(\"Error: \", error);\n      return error;\n    }\n  };\n\nexport const delTokenFromList = (data) => async (dispatch, getState) => {\n  try {\n    const {\n      persist: { tokenList },\n    } = getState();\n    tokenList.splice(\n      tokenList.findIndex(\n        (a) => a.address.toLowerCase() === data.address.toLowerCase()\n      ),\n      1\n    );\n    return tokenList;\n  } catch (error) {\n    console.log(\"Error: \", error);\n    return error;\n  }\n};\n\nexport const getUserLPTokens = () => async (dispatch, getState) => {\n  try {\n    const {\n      persist: { updateUserLpTokens },\n    } = getState();\n    if (!updateUserLpTokens) {\n      dispatch(saveUserLpTokens([]));\n      let lpTokensCount = await UserService.getPairsCount();\n      lpTokensCount = lpTokensCount.data.count;\n\n      const limit = 100;\n      const totalPages = Math.ceil(lpTokensCount / limit);\n      // let lpTokensArr = [];\n      for (let page = 1; page <= totalPages; page++) {\n        let lpTokens = await UserService.getPairs({ page, limit });\n\n        lpTokens = lpTokens.data;\n        // lpTokensArr = lpTokensArr.concat(lpTokens);\n        for (let lp of lpTokens) {\n          await dispatch(commonLpToken(lp));\n        }\n\n        // console.log(\"LPTOKENS:\", lpTokens);\n      }\n    }\n  } catch (error) {\n    console.log(\"Error: \", error);\n    return error;\n  }\n};\nexport const commonLpToken = (lp) => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        persist: { isUserConnected, tokenList, userLpTokens },\n      } = getState();\n      const balance = await ContractServices.getTokenBalanceFull(\n        lp.pair,\n        isUserConnected\n      );\n      if (balance > 0) {\n        let userLpTokensArr = userLpTokens;\n        let token0Obj = {},\n          token1Obj = {},\n          token0Deposit = 0,\n          token1Deposit = 0,\n          poolShare = \"0\",\n          ratio = 0;\n        const totalSupply = await ContractServices.getTotalSupply(lp.pair);\n\n        ratio = balance / totalSupply;\n        poolShare = ((balance / totalSupply) * 100).toFixed(2);\n\n        const reserves = await ExchangeService.getReserves(lp.pair);\n\n        if (lp.token0.toLowerCase() === WETH.toLowerCase()) {\n          token0Obj = tokenList.find((d) => d.address === \"BNB\");\n        } else {\n          token0Obj = tokenList.find(\n            (d) => d.address.toLowerCase() === lp.token0.toLowerCase()\n          );\n        }\n        if (lp.token1.toLowerCase() === WETH.toLowerCase()) {\n          token1Obj = tokenList.find((d) => d.address === \"BNB\");\n        } else {\n          token1Obj = tokenList.find(\n            (d) => d.address.toLowerCase() === lp.token1.toLowerCase()\n          );\n        }\n        //lp deposit\n        token0Deposit = (\n          ratio *\n          (reserves[\"_reserve0\"] / 10 ** token0Obj.decimals)\n        );\n        token1Deposit = (\n          ratio *\n          (reserves[\"_reserve1\"] / 10 ** token1Obj.decimals)\n        );\n\n        const data = {\n          ...lp,\n          token0Obj,\n          token1Obj,\n          token0Deposit,\n          token1Deposit,\n          balance,\n          poolShare,\n        };\n        userLpTokensArr = [...userLpTokensArr, data];\n        dispatch(\n          saveUserLpTokens(userLpTokensArr)\n        );\n      }\n    } catch (error) {\n\n    }\n  }\n}\n\nexport const addLpToken = (lp) => {\n  return async (dispatch, getState) => {\n    try {\n      const {\n        persist: { isUserConnected, tokenList, userLpTokens },\n      } = getState();\n      if (lp) {\n        dispatch(checkUserLpTokens(true));\n        let userLpTokensArr = userLpTokens;\n\n        const balance = await ContractServices.getTokenBalanceFull(\n          lp.pair,\n          isUserConnected\n        );\n        if (balance > 0) {\n          let token0Obj = {},\n            token1Obj = {},\n            token0Deposit = 0,\n            token1Deposit = 0,\n            poolShare = \"0\",\n            ratio = 0;\n          const totalSupply = await ContractServices.getTotalSupply(lp.pair);\n\n          ratio = balance / totalSupply;\n          poolShare = ((balance / totalSupply) * 100).toFixed(2);\n\n          const reserves = await ExchangeService.getReserves(lp.pair);\n\n          if (lp.token0.toLowerCase() === WETH.toLowerCase()) {\n            lp.token0 = 'BNB';\n            token0Obj = tokenList.find((d) => d.address === \"BNB\");\n          } else {\n            token0Obj = tokenList.find(\n              (d) => d.address.toLowerCase() === lp.token0.toLowerCase()\n            );\n          }\n          if (lp.token1.toLowerCase() === WETH.toLowerCase()) {\n            lp.token1 = 'BNB';\n            token1Obj = tokenList.find((d) => d.address === \"BNB\");\n          } else {\n            token1Obj = tokenList.find(\n              (d) => d.address.toLowerCase() === lp.token1.toLowerCase()\n            );\n          }\n          //lp deposit\n          token0Deposit = (\n            ratio *\n            (reserves[\"_reserve0\"] / 10 ** token0Obj.decimals)\n          );\n          token1Deposit = (\n            ratio *\n            (reserves[\"_reserve1\"] / 10 ** token1Obj.decimals)\n          );\n\n          const data = {\n            ...lp,\n            token0Obj,\n            token1Obj,\n            token0Deposit,\n            token1Deposit,\n            balance,\n            poolShare,\n          };\n          let check = true;\n          for (let oldLp of userLpTokens) {\n            if (oldLp.pair.toLowerCase() === lp.pair.toLowerCase()) {\n              check = false;\n            }\n          }\n          if (check) {\n            userLpTokensArr = [...userLpTokensArr, data];\n            await dispatch(\n              saveUserLpTokens(userLpTokensArr)\n            );\n          }\n          return data;\n        } else {\n          return null;\n        }\n      }\n    } catch (error) {\n      console.log(\"Error: \", error);\n      return error;\n    }\n  };\n};\n"]},"metadata":{},"sourceType":"module"}